#!/bin/bash
###############################################################################
# NOTE: Use /bin/bash to ensure script uses macOS Bash version.
#
# Notes.app CLI
#
# A command line interface for Notes.app.
#
# https://github.com/xwmx/notes-app-cli
#
# Based on Bash Boilerplate: https://github.com/xwmx/bash-boilerplate
#
# Copyright (c) 2020 William Melody â€¢ hi@williammelody.com
# GPLv2 â€¢ See LICENSE for details.
###############################################################################

###############################################################################
# Strict Mode
#
# More Information:
#   https://github.com/xwmx/bash-boilerplate#bash-strict-mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
set -o noglob
IFS=$'\n\t'

###############################################################################
# Platform Check
###############################################################################

if [[ ! "$OSTYPE" =~ ^darwin ]]
then
  printf "notes-app-cli only works on macOS.\\nExiting...\\n"
  exit 0
fi

###############################################################################
# Environment
###############################################################################

# $_VERSION
#
# The most recent program version.
_VERSION="0.0.2"

# $_ME
#
# Set to the program's basename.
_ME="$(basename "${0}")"

# $_MY_PATH
#
# Set to the program's full path.
# shellcheck disable=SC2034
_MY_PATH="$(cd "$(dirname "$0")"; pwd)/$(basename "${0}")"

# $_MY_PROJECT_NAME
#
# Set to the program's project name.
# shellcheck disable=SC2034
_MY_PROJECT_NAME="notes-app-cli"

# $_MY_GITHUB_REPO
#
# Set to the program's primary GitHub repository URL.
# shellcheck disable=SC2034
_MY_GITHUB_REPO="xwmx/notes-app-cli"

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

# $_SED_I_COMMAND
#
# `sed -i` takes an extension on macOS, but that extension can cause errors in
# GNU `sed`.
#
# NOTE: To use this command, call it with `"${_SED_I_COMMAND[@]}"`
#
# https://stackoverflow.com/q/43171648
# http://stackoverflow.com/a/16746032
if sed --help >/dev/null 2>&1
then # GNU
  export _SED_I_COMMAND=(sed -i)
else # macOS
  export _SED_I_COMMAND=(sed -i '')
fi

###############################################################################
# .notes-apprc
###############################################################################

# .notes-apprc
#
# If a `.notes-apprc` file exists in `$HOME`, source it.
export _MY_RC_PATH="${_MY_RC_PATH:-${HOME}/.notes-apprc}"
if [[ -e "${_MY_RC_PATH}" ]]
then
  _MY_RC_PATH="$(realpath "${_MY_RC_PATH}")"
  source "${_MY_RC_PATH}"
fi

###############################################################################
# $EDITOR
###############################################################################

# Set default $EDITOR if one has not been set.
if [[ -z "${EDITOR:-}" ]]
then
  if hash "code" 2>/dev/null
  then
    export EDITOR="code"
  elif hash "subl" 2>/dev/null
  then
    export EDITOR="subl"
  elif hash "mate" 2>/dev/null
  then
    export EDITOR="mate"
  elif hash "nano" 2>/dev/null
  then
    export EDITOR="nano"
  elif hash "vi" 2>/dev/null
  then
    export EDITOR="vi"
  else
    _die printf "\$EDITOR not found. Set the editor in ~/.notesrc\\n"
  fi
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
  fi
}

# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "${@}" 1>&2
  exit 1
}

# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# Temp Directory
###############################################################################

export _MY_TEMP_DIRECTORY
_MY_TEMP_DIRECTORY="$(mktemp -d)"

# Usage: _tempfile_path <basename>
_tempfile_path() {
  [[ -z "${1:-}" ]] && return 1
  printf "%s/%s" "${_MY_TEMP_DIRECTORY}" "${1:-}"
}

# Usage: _my_cleanup_on_exit
_my_cleanup_on_exit() {
  if [[ -n "${_MY_TEMP_DIRECTORY:-}" ]] &&
     [[ -e "${_MY_TEMP_DIRECTORY}"   ]]
  then
    rm -rf "${_MY_TEMP_DIRECTORY}"
  fi
}

trap _my_cleanup_on_exit EXIT

###############################################################################
# Configuration
###############################################################################

# `$_MY_DEFAULT_ACCOUNT_NAME`
export _MY_DEFAULT_ACCOUNT_NAME="${_MY_DEFAULT_ACCOUNT_NAME:-iCloud}"

# `$_MY_DEFAULT_FOLDER_NAME`
export _MY_DEFAULT_FOLDER_NAME="${_MY_DEFAULT_FOLDER_NAME:-Notes}"

# `$_MY_HIGHLIGHT_COLOR`
#
# Default: 11 (yellow) for 256 color terminals, 3 (yellow) for 8 color.
#
# Set highlighting color. This should be set to an xterm color number, usually
# a value between 1 and 256. For a table colors and their numbers run:
#
#   notes settings colors
#
# Supported Values: [0..255]
_set_my_highlight_color() {
  local _colors=
  _colors="$(tput colors)"
  if [[ -n "${_colors}" ]] && [[ "${_colors}" -gt 8 ]]
  then
    export _MY_HIGHLIGHT_COLOR="${_MY_HIGHLIGHT_COLOR:-11}"
  else
    export _MY_HIGHLIGHT_COLOR="${_MY_HIGHLIGHT_COLOR:-3}"
  fi
} && _set_my_highlight_color

###############################################################################
# Helpers
###############################################################################

# _alias_subcommand()
#
# Usage:
#   _alias_subcommand <subcommand> <alias>
#
# Description:
#   Create an <alias> of <subcommand>. NOTE: aliases also have to be added to
#   the $_SUBCOMMANDS variable.
_alias_subcommand() {
  local _subcommand="${1:-}"
  local _alias="${2:-}"
  if [[ -z "${_subcommand}" ]] || [[ -z "${_alias}" ]]
  then
    return 1
  fi

  local _subcommand_help
  _subcommand_help="$(
    printf "%s\\n" "${_subcommand}" | cut -d' ' -f1
  )"

  eval "desc \"${_alias}\" \"\$(_help '${_subcommand_help}')\""
  eval "_${_alias}() { _${_subcommand} \"\${@}\"; }"
}

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Takes a potential command <name> as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _test_list=(${*:2})
  for __test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \${__test_element}: %s\\n" "${__test_element}"
    if [[ "${__test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _edit_file()
#
# Usage:
#   _edit_file <path> [--no-wait]
#
# Description:
#   Open the file in $EDITOR. Use the `-f` option in vim and `--wait` option in
#   other GUI editors to wait until the file is closed in the editor before
#   continuing, unless `--no-wait`.
_edit_file() {
  local _file_path="${1:-}"
  local _wait=1

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --no-wait)
        _wait=0
        ;;
      *)
        if [[ -z "${_file_path}" ]]
        then
          _file_path="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_file_path}" ]]
  then
    return 1
  fi

  if ((_wait)) &&
     [[ "${EDITOR}" =~ mvim ]] ||
     [[ "${EDITOR}" =~ gvim ]]
  then
    "${EDITOR}" -f "${_file_path}"
  elif ((_wait)) &&
       [[ "${EDITOR}" =~ code ]] ||
       [[ "${EDITOR}" =~ mate ]] ||
       [[ "${EDITOR}" =~ subl ]]
  then
    "${EDITOR}" --wait "${_file_path}"
  else
    "${EDITOR}" "${_file_path}"
  fi
}

# _file_is_text()
#
# Usage:
#   _file_is_text <path>
#
# Returns:
#   0  If file is text.
#   1  if not.
_file_is_text() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # Avoid calling `file` for better performance.
  [[ "${_file_type}" =~ ^html|latex|md|markdown|org|rst|textile|txt$ ]] ||
    [[ "$(file -b --mime-type "${1:-}")" =~ ^text ]]
}

# _get_hash()
#
# Usage:
#   _get_hash <path>
#
# Description:
#   Generate a hash for the file at the given <path>.
_get_hash() {
  local _hash
  if _command_exists "md5sum"
  then
    _hash="$(md5sum "${1:-}" | awk '{ print $1 }')"
  elif _command_exists "md5"
  then
    _hash="$(md5 -q "${1:-}")"
  fi
  printf "%s\\n" "${_hash}"
}


# _get_id_normalized()
#
# Usage:
#   _get_id_normalized <id>
#
# Returns:
#   Return a formatted id suitable for including in AppleScript.
_get_id_normalized() {
  local _id="${1:-}"
  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "$(_get_id_type "${_id}")" == "id" ]]
  then
    _id="\"${_id}\""
  elif [[ "$(_get_id_type "${_id}")" == "number" ]]
  then # enclose name in quotes
    _id="\"${_id}\""
  fi

  printf "%s\\n" "${_id}"
}

# _get_id_selector()
#
# Usage:
#   _get_id_selector <id>
#
# Returns:
#   A formatted id suitable as a simple selector in AppleScript.
_get_id_selector() {
  local _id="${1:-}"
  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "$(_get_id_type "${_id}")" == "id" ]]
  then
    _id="id \"${_id}\""
  elif [[ ! "$(_get_id_type "${_id}")" == "number" ]]
  then # enclose name in quotes
    _id="\"${_id}\""
  fi

  printf "%s\\n" "${_id}"
}

# _get_id_type()
#
# Usage:
#   _get_id_type <id>
#
# Returns:
#   id      If id is a Notes.app id.
#   name    If the id is a name.
#   number  If the id is a number.
_get_id_type() {
  local _id="${1:-}"
  local _type=

  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "${_id}" =~ x\-coredata\:\/\/ ]]
  then
    _type="id"
  elif [[ "${_id}" =~ ^[[:digit:]]+$ ]]
  then
    _type="number"
  else
    _type="name"
  fi

  printf "%s\\n" "${_type}"
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
export _TPUT_HIGHLIGHT_COLOR
_TPUT_HIGHLIGHT_COLOR="$(tput setaf "${_MY_HIGHLIGHT_COLOR}")"
export _TPUT_SGR0=    && _TPUT_SGR0="$(tput sgr0)"
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi

  printf "${_TPUT_HIGHLIGHT_COLOR:-}%s${_TPUT_SGR0:-}\\n" "${_input}"
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# __option_value_is_present()
#
# Usage:
#   __option_value_is_present "${variable}"
#
# Returns:
#   0  The argument is present and does not match an option flag.
#   1  The argument is blank or matches as an option flag.
__option_value_is_present() {
  [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  local _line=
  _text_length=${#_text}
  printf -v _line '%*s' "${_text_length}"
  printf "%s\\n" "${_line// /-}"
}

# _setup_folder()
#
# Usage:
#   _setup_folder <folder>
#
# Description:
#   Setup the folder to use for the subcommand.
_setup_folder() {
  local _folder_name="${1:-}"
  printf "%s\\n" "${_folder_name}"
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

# _validate_account_contains_folder()
#
# Usage:
#   _validate_account_contains_folder <account> <folder>
#
# Returns:
#   0  If the <account> contains <folder>.
#   1  If not.
_validate_account_contains_folder() {
  local _account_name="${1:-}"
  local _folder_name="${2:-}"

  if [[ -z "${_account_name:-}" ]] || [[ -z "${_folder_name:-}" ]]
  then
    return 1
  fi

  local _account_folders
  _account_folders="$(_folders --account "${_account_name}")"

  _contains "${_folder_name}" "${_account_folders[@]}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _die printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _die printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# help
###############################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand> | -l | --long]

Options:
  -l --long  Include a list of subcommands and their descriptions.

Description:
  Print the program help information. When a subcommand name is passed, print
  the help information for the subcommand.

Shortcut Alias: \`h\`
HEREDOC
_help() {
  if [[ -z "${1:-}" ]] || [[ "${1}" =~ ^-l$|^--long$ ]]
  then
    cat <<HEREDOC
Notes.app CLI

A command line interface for Notes.app on macOS.

Usage:
  ${_ME} add --body <body> --name <name> [--account <account>]
                [--folder <folder>]
  ${_ME} commands
  ${_ME} count [--account <account>] [--folder <folder>]
  ${_ME} delete <note> [--account <account>] [--folder <folder>]
  ${_ME} folders [show <folder>] [--account <account>] [--folder <folder>]
                    [--properties <prop1>,<prop2>]
  ${_ME} list [--account <account>] [--folder <folder>]
                 [--properties <prop1>,<prop2>]
  ${_ME} show <note> [--account <account>] [--folder <folder>] [--open]
                 [--properties <prop1>,<prop2>]
  ${_ME} update <note> (--body <body> | --name <name>) [--account <account>]
                   [--folder <folder>]
  ${_ME} -h | --help | help [<subcommand>] [-l | --long]
  ${_ME} --version | version

Help:
  ${_ME} help [<subcommand>]

More Information:
  https://github.com/${_MY_GITHUB_REPO}
HEREDOC

    if [[ "${1:-}" =~ ^-l$|^--long$ ]]
    then
      cat <<HEREDOC

Subcommands:
  (default)
  help         Display this help information.
  version      Display version information.

Program Options:
  -h --help         Display this help information.
  --version         Display version information.
HEREDOC
    fi
  else
    desc --get "${@}"
  fi
}
_alias_subcommand "help" "h"

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

desc "add" <<HEREDOC
Usage:
  ${_ME} add --body <body> --name <name> [--account <account>]
                [--folder <folder>]

Options:
  --account <account>  The account containing the new note.
  --folder  <folder>   The folder containing the new note.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Add a new note.
HEREDOC
_add() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _body=
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _name=
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      --body)
        if __option_value_is_present "${_val:-}"
        then
          _body="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      --name)
        if __option_value_is_present "${_val:-}"
        then
          _name="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      *)
        :
        ;;
    esac

    shift
  done

  if [[ -z "${_account_name:-}" ]]
  then
    _help "add"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "add"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -n "${_body:-}" ]] && [[ -n "${_name:-}" ]]
  then
    _properties="{name:\"${_name}\", body:\"${_body}\"}"
  elif [[ -n "${_body:-}" ]]
  then
    _properties="{body:\"${_body}\"}"
  elif [[ -n "${_name:-}" ]]
  then
    _properties="{name:\"${_name}\"}"
  fi

  read -r -d '' _script <<HEREDOC || true
tell application "Notes"
    tell account ${_account_name}
        make new note at folder ${_folder_name} with properties ${_properties}
    end tell
end tell
HEREDOC

  _debug printf "\${_script}: %s\\n" "${_script:-}"

  osascript -e "${_script}" 2>&1
}

# commands ####################################################################

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands

Description:
  List available commands.
HEREDOC
_commands() {
  printf "%s\\n" "${_SUBCOMMANDS[*]}"
}

# completions #################################################################

desc "completions" <<HEREDOC
Usage:
  ${_ME} completions (check | install [-d | --download] | uninstall)

Options:
  -d --download  Download the completion scripts and install.

Description:
  Manage completion scripts.
HEREDOC
_completions() {
  local _BASH_COMP_NAME="notes-app"
  local _ZSH_COMP_NAME="_notes-app"

  # Usage: _completions_check
  _completions_check() {
    local _bash_completion_path=
    _bash_completion_path="$(_get_bash_completion_path)"

    local _exists=0

    if [[ -n "${_bash_completion_path:-}" ]] &&
       [[ -d "${_bash_completion_path}"   ]]
    then
      if [[ -w "${_bash_completion_path}"   ]]
      then
        if [[ -e "${_bash_completion_path}/${_BASH_COMP_NAME}" ]]
        then
          _exists=1
          printf "Exists: %s\\n" "${_bash_completion_path}/${_BASH_COMP_NAME}"
        fi
      else
        printf "Permission denied: %s\\n" "${_bash_completion_path}"
      fi
    fi

    local _zsh_completion_path="/usr/local/share/zsh/site-functions"

    if [[ -d "${_zsh_completion_path}" ]]
    then
      if [[ -w "${_zsh_completion_path}" ]]
      then
        if [[ -e "${_zsh_completion_path}/${_ZSH_COMP_NAME}" ]]
        then
          _exists=1
          printf "Exists: %s\\n" "${_zsh_completion_path}/${_ZSH_COMP_NAME}"
        fi
      else
        printf "Permission denied: %s\\n" "${_zsh_completion_path}"
      fi
    fi

    if ! ((_exists))
    then
      printf "Completion scripts not found.\\n"
      return 1
    fi
  }

  # Usage: _get_bash_completion_path
  _get_bash_completion_path() {
    local _bash_completion_path=

    if [[ -n "${BASH_COMPLETION_COMPAT_DIR:-}" ]]
    then
      _bash_completion_path="${BASH_COMPLETION_COMPAT_DIR}"
    fi

    if [[ -z "${_bash_completion_path:-}" ]]
    then
      local _maybe_path
      _maybe_path="$(
        pkg-config --variable=completionsdir bash-completion 2>/dev/null || true
      )"

      if [[ -n "${_maybe_path:-}" ]]
      then
        _bash_completion_path="${_maybe_path}"
      fi
    fi

    if [[ -z "${_bash_completion_path:-}"       ]] &&
       [[ -d "/usr/local/etc/bash_completion.d" ]]
    then
      _bash_completion_path="/usr/local/etc/bash_completion.d"
    fi

    if [[ -z "${_bash_completion_path:-}" ]] &&
       [[ -d "/etc/bash_completion.d"     ]]
    then
      _bash_completion_path="/etc/bash_completion.d"
    fi

    printf "%s\\n" "${_bash_completion_path:-}"
  }

  # Usage: _completions_install [--download]
  _completions_install() {
    local _download=0
    if [[ "${1:-}" == "--download" ]]
    then
      _download=1
    fi

    local _my_dir=
    _my_dir="$(cd "$(dirname "$(realpath "$0")")"; pwd)"
    if [[ -z "${_my_dir}" ]] || [[ ! -d "${_my_dir}" ]]
    then
      exit 1
    fi

    local _my_raw_url="https://raw.githubusercontent.com/${_MY_GITHUB_REPO}/master"

    for _shell in bash zsh
    do
      local _completion_source="${_my_dir}/etc/notes-completion.${_shell}"

      if ((_download))
      then
        if [[ ! -f "${_completion_source}" ]]
        then
          _completion_source="$(mktemp)"
          local _completion_url="${_my_raw_url}/etc/notes-completion.${_shell}"

          if ! _download_from "${_completion_url}" "${_completion_source}"
          then
            printf "Unable to download Completion script from %s\\n" \
              "${_completion_source}"
            return 1
          fi
        fi
      fi

      if [[ ! -f "${_completion_source}" ]]
      then
        cat <<HEREDOC
Unable to find source ${_shell} completion script. You can try downloading
and installing the latest version with the following command (\`sudo\` might
be necessary):
  ${_ME} completions install --download

More information: ${_shell}
  https://github.com/${_MY_GITHUB_REPO}/blob/master/etc/README.md
HEREDOC
      else
        local _completion_path=
        local _completion_target=
        if [[ "${_shell}" == "bash" ]]
        then
          _completion_path="$(_get_bash_completion_path)"
          _completion_target="${_completion_path}/${_BASH_COMP_NAME}"
        elif [[ "${_shell}" == "zsh" ]]
        then
          _completion_path="/usr/local/share/zsh/site-functions"
          _completion_target="${_completion_path}/${_ZSH_COMP_NAME}"
        fi

        if [[ -n "${_completion_path:-}" ]] &&
           [[ -d "${_completion_path}"   ]]
        then
          if [[ -w "${_completion_path}" ]]
          then
            if [[ ! -e "${_completion_target}" ]]
            then
              cp \
                "${_completion_source}" \
                "${_completion_target}"
              chmod +r "${_completion_target}"
              printf "Completion script installed: %s\\n" \
                "${_completion_target}"
            else
              printf "Exists: %s\\n" "${_completion_target}"
            fi
          else
            printf "Permission denied: %s\\n" "${_completion_path}"
          fi
        fi
      fi
    done
  }

  # Usage: _completions_uninstall
  _completions_uninstall() {
    local _completion_path=
    local _completion_target=

    for _shell in bash zsh
    do
      if [[ "${_shell}" == "bash" ]]
      then
        _completion_path="$(_get_bash_completion_path)"
        _completion_target="${_completion_path}/${_BASH_COMP_NAME}"
      elif [[ "${_shell}" == "zsh" ]]
      then
        _completion_path="/usr/local/share/zsh/site-functions"
        _completion_target="${_completion_path}/${_ZSH_COMP_NAME}"
      fi

      if [[ -n "${_completion_path:-}" ]] &&
         [[ -d "${_completion_path}"   ]]
      then
        if [[ -w "${_completion_path}"   ]] &&
           [[ -w "${_completion_target}" ]]
        then
          if [[ -f "${_completion_target}" ]]
          then
            rm "${_completion_target}"
            printf "Completion script removed: %s\\n" \
              "${_completion_target}"
          fi
        else
          printf "Permission denied: %s\\n" "${_completion_path}"
        fi
      fi
    done
  }

  local _subcommand="${1:-}"

  case "${_subcommand}" in
    check)
      _completions_check
      ;;
    install)
      if [[ "${2:-}" =~ ^-d|--download$ ]]
      then
        _completions_install --download
      else
        _completions_install
      fi
      ;;
    uninstall)
      _completions_uninstall
      ;;
    *)
      _help "completions"
      return 0
      ;;
  esac
}

# count #######################################################################

desc "count" <<HEREDOC
Usage:
  ${_ME} count [--account <account>] [--folder <folder>]

Description:
  Print the number of notes in <folder>.
HEREDOC
_count() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
    esac

    shift
  done

  if [[ -n "${_folder_name:-}" ]] &&
    ! _validate_account_contains_folder "${_account_name}" "${_folder_name}"
  then
    printf "Account '%s' does not contain folder '%s'.\\n" \
      "${_account_name}" "${_folder_name}"
    return 1
  fi

  if [[ -z "${_account_name:-}" ]]
  then
    _help "count"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "count"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  local _script=
  read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    set myFolder to folder ${_folder_name}
    get the count of notes of myFolder
  end tell
end tell
HEREDOC

  osascript -e "${_script}" 2>&1
}

# delete ######################################################################

desc "delete" <<HEREDOC
Usage:
  ${_ME} delete <note> [--account <account>] [--folder <folder>]

Options:
  --account <account>  The account containing the note.
  --folder  <folder>   The folder containing the note.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Delete <note>.
HEREDOC
_delete() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _force=0
  local _id=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "delete"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "delete"
          return 1
        fi
        ;;
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_account_name:-}" ]]
  then
    _help "show"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "show"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_id:-}" ]]
  then
    _help "show"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if ! ((_force))
  then
    printf "Deleting '%s' in folder '%s'\\n" "${_id}" "${_folder_name}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      delete note ${_id}
    end tell
  end tell
end tell
HEREDOC

  osascript -e "${_script}" 2>&1
}

# edit ########################################################################

# env #########################################################################

desc "env" <<HEREDOC
Usage:
  ${_ME} env

Description:
  Print program environment variables.
HEREDOC
_env() {
  printf "EDITOR=%s\\n" "${EDITOR}"
  printf "_MY_TEMP_DIRECTORY=%s\\n" "${_MY_TEMP_DIRECTORY}"
  printf "_MY_HIGHLIGHT_COLOR=%s\\n" "${_MY_HIGHLIGHT_COLOR}"
  printf "_MY_RC_PATH=%s\\n" "${_MY_RC_PATH}"
}


# folders #####################################################################

desc "folders" <<HEREDOC
Usage:
  ${_ME} folders [show <folder>] [--account <account>] [--folder <folder>]
                    [--properties <prop1>,<prop2>]

Options:
  --account    <account>        The account containing the folder.
  --folder     <folder>         The parent folder, if any.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  container
  name

Description:
  List folders in an account.
HEREDOC
_folders() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _properties=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "folders"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "folders"
          return 1
        fi
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "folders"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "folders"
    return 1
  else
    local _account_query=
    if [[ "$(_get_id_type "${_account_name}")" == "id" ]]
    then
      _account_query="set myAccount to first account whose id = ${_account_name}"
    elif [[ "$(_get_id_type "${_account_name}")" == "number" ]]
    then
      _account_query="set myAccount to account ${_account_name}"
    else
      _account_query="set myAccount to first account whose name = \"${_account_name}\""
    fi
  fi

  _debug printf "\${_folder_name}: %s\\n" "${_folder_name:-}"

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  if [[ -z "${_folder_name}" ]]
  then
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  ${_account_query}
  tell myAccount
    set myFolders to folders of myAccount
    set myCounter to 0

    repeat with theFolder in myFolders
      tell theFolder
        set myCounter to myCounter + 1
        set folderContainer to get container
        set folderId to get id
        set folderName to get name

        -- log myCounter
HEREDOC

    read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end repeat
  end tell
end tell
HEREDOC
  else
    local _folder_query=
    if [[ "$(_get_id_type "${_folder_name}")" == "id" ]]
    then
      _folder_query="set myFolder to first folder whose id = ${_folder_name}"
    elif [[ "$(_get_id_type "${_folder_name}")" == "number" ]]
    then
      _folder_query="set myFolder to folder ${_folder_name}"
    else
      _folder_query="set myFolder to first folder whose name = \"${_folder_name}\""
    fi

    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  ${_account_query}
  tell myAccount
    ${_folder_query}
    tell myFolder
      set myFolders to folders of myFolder
      set myCounter to 0

      repeat with theFolder in myFolders
        tell theFolder
          set myCounter to myCounter + 1
          set folderContainer to get container
          set folderId to get id
          set folderName to get name

          -- log myCounter
HEREDOC

    read -r -d '' _script_footer <<HEREDOC || true
        end tell
      end repeat
    end tell
  end tell
end tell
HEREDOC
  fi

  if [[ "${_properties}" =~ container|^all$ ]]
  then
    _script_properties+=("log folderContainer")
  fi

  if [[ "${_properties}" =~ id|^all$ ]]
  then
    _script_properties+=("log folderId")
  fi

  if [[ "${_properties}" =~ name|^all$ ]]
  then
    _script_properties+=("log folderName")
  fi

  if [[ -z "${_script_properties[*]:-}" ]]
  then # no properties were specified
    _script_properties+=("log folderName")
  fi

local _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# list ########################################################################

desc "list" <<HEREDOC
Usage:
  ${_ME} list [--account <account>] [--folder <folder>]
                 [--properties <prop1>,<prop2>]

Options:
  --account <account>           The account containing the note.
  --folder  <folder>            The folder containing the note.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  counter
  id
  container
  passwordProtected
  creationDate
  modificationDate
  name
  body

Description:
  List notes.
HEREDOC
_list() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _properties=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "list"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "list"
          return 1
        fi
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "folders"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "list"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "list"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    set myFolder to folder ${_folder_name}
    set myNotes to notes of myFolder
    set myCounter to 0

    repeat with theNote in myNotes
      tell theNote
        set myCounter to myCounter + 1
        set noteContainer to get container
        set noteId to get id
        set notePasswordProtected to get password protected
        set noteCreationDate to get creation date
        set noteModificationDate to get modification date
        set noteName to get name
        set noteBody to get body
HEREDOC

  if [[ "${_properties}" =~ counter|^all$ ]]
  then
    _script_properties+=("log myCounter")
  fi

  if [[ "${_properties}" =~ id|^all$ ]]
  then
    _script_properties+=("log noteId")
  fi

  if [[ "${_properties}" =~ container|^all$ ]]
  then
    _script_properties+=("log noteContainer")
  fi

  if [[ "${_properties}" =~ passwordProtected|^all$ ]]
  then
    _script_properties+=("log notePasswordProtected")
  fi

  if [[ "${_properties}" =~ creationDate|^all$ ]]
  then
    _script_properties+=("log noteCreationDate")
  fi

  if [[ "${_properties}" =~ modificationDate|^all$ ]]
  then
    _script_properties+=("log noteModificationDate")
  fi

  if [[ "${_properties}" =~ name|^all$ ]]
  then
    _script_properties+=("log noteName")
  fi

  if [[ "${_properties}" =~ body|^all$ ]]
  then
    _script_properties+=("log noteBody")
  fi

  if [[ -z "${_script_properties[*]:-}" ]]
  then # no properties were specified
    _script_properties+=("log noteName")
  fi

  read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end repeat
  end tell
end tell
HEREDOC

local _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# show ########################################################################

desc "show" <<HEREDOC
Usage:
  ${_ME} show <note> [--account <account>] [--folder <folder>] [--open]
                 [--properties <prop1>,<prop2>]

Options:
  --account    <account>        The account containing the note.
  --folder     <folder>         The folder containing the note.
  --open                        Open the note in Notes.app.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  container
  passwordProtected
  creationDate
  modificationDate
  name
  body

Description:
  Show a note idenitied by <id>, <name>, or <number>.
HEREDOC
_show() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _id=
  local _open_in_app=0
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "show"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "show"
          return 1
        fi
        ;;
      --open)
        _open_in_app=1
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "show"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "show"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "show"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_id:-}" ]]
  then
    _help "show"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if ((_open_in_app))
  then
    read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      show note ${_id}
    end tell
  end tell
end tell
HEREDOC
  else
    local _script_footer=
    local _script_header=
    local -a _script_properties=()

    if [[ -z "${_properties:-}" ]]
    then # no properties were specified
      _properties="all"
    fi

    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      tell note ${_id}
        set noteId to get id
        set noteContainer to get container
        set notePasswordProtected to get password protected
        set noteCreationDate to get creation date
        set noteModificationDate to get modification date
        set noteName to get name
        set noteBody to get body
        set noteId to get id
HEREDOC
    if [[ "${_properties}" =~ id|^all$ ]]
    then
      _script_properties+=("log noteId")
    fi

    if [[ "${_properties}" =~ container|^all$ ]]
    then
      _script_properties+=("log noteContainer")
    fi

    if [[ "${_properties}" =~ passwordProtected|^all$ ]]
    then
      _script_properties+=("log notePasswordProtected")
    fi

    if [[ "${_properties}" =~ creationDate|^all$ ]]
    then
      _script_properties+=("log noteCreationDate")
    fi

    if [[ "${_properties}" =~ modificationDate|^all$ ]]
    then
      _script_properties+=("log noteModificationDate")
    fi

    if [[ "${_properties}" =~ name|^all$ ]]
    then
      _script_properties+=("log noteName")
    fi

    if [[ "${_properties}" =~ body|^all$ ]]
    then
      _script_properties+=("log noteBody")
    fi

    read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end tell
  end tell
end tell
HEREDOC

_script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"
  fi

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# update ######################################################################

desc "update" <<HEREDOC
Usage:
  ${_ME} update <note> (--body <body> | --name <name>) [--account <account>]
                   [--folder <folder>]

Options:
  --account <account>  The account containing the note.
  --body    <body>     The new value for the note body.
  --folder  <folder>   The folder containing the note.
  --name    <name>     The new value for the note name.

Identifiers:
  <notes>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Update a note.
HEREDOC
_update() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _body=
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _id=
  local _name=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --body)
        if __option_value_is_present "${_val:-}"
        then
          _body="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --name)
        if __option_value_is_present "${_val:-}"
        then
          _name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_id:-}" ]]
  then
    _help "update"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if [[ -z "${_account_name:-}" ]]
  then
    _help "update"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "update"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_body:-}" ]] && [[ -z "${_name:-}" ]]
  then
    return 1
  fi

  local _script_header=
  local _script_body=
  local _script_name=
  local _script_footer=

  read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      tell note ${_id}
HEREDOC
  if [[ -n "${_body:-}" ]]
  then
    _script_body="set the body of it to \"${_body}\""
  fi

  if [[ -n "${_name:-}" ]]
  then
    _script_name="set the name of it to \"${_name}\""
  fi
  read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end tell
  end tell
end tell
HEREDOC

local _script="\
${_script_header}
${_script_body}
${_script_name}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1 &&
    printf "Updated Note.\\n"
}

# version ####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\\n" "${_VERSION}"
}

###############################################################################
# _notes_app_main()
###############################################################################

# _notes_app_main()
#
# Description:
#   Call the appropriate subcommand.
_notes_app_main() {
  _debug printf "_notes_app_main() >> start\\n"
  _debug printf "_notes_app_main() \${@}: '%s'\\n" "${@}"
  _debug printf "_notes_app_main() \${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="help"
  fi

  case "${_SUBCOMMAND}" in
    commands|completions|env|help|version)
      "_${_SUBCOMMAND}" "${@}"
      ;;
    *)
      "_${_SUBCOMMAND}" "${@}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_ARGUMENTS=()

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  add
  commands
  completions
  count
  delete
  env
  folders
  h
  help
  list
  show
  update
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"



# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  case "${1:-}" in
    ${_SUBCOMMANDS_PATTERN})
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while ((${#}))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    *)
      if [[ -z "${_SUBCOMMAND:-}" ]] && _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\${_SUBCOMMANDS[*]}: '%s'\\n" "${_SUBCOMMANDS[*]}"
_debug printf "\${_SUBCOMMANDS_PATTERN}: '%s'\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"
_debug printf "\${_ARGUMENTS[*:-]}: '%s'\\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Describe:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("${_PRINT_HELP}"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("${_PRINT_VERSION}"))
  then
    _version
  else
    _notes_app_main "${_ARGUMENTS[@]:-}"
  fi
}

_main "${@:-}"
