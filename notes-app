#!/bin/bash
###############################################################################
# NOTE: Use /bin/bash to ensure script uses macOS Bash version.
#
# Notes.app CLI
#
# A command line interface for Notes.app.
#
# https://github.com/xwmx/notes-app-cli
#
# Based on Bash Boilerplate: https://github.com/xwmx/bash-boilerplate
#
# Copyright (c) 2020 William Melody • hi@williammelody.com
# GPLv2 • See LICENSE for details.
###############################################################################

###############################################################################
# Strict Mode
#
# More Information:
#   https://github.com/xwmx/bash-boilerplate#bash-strict-mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
set -o noglob
IFS=$'\n\t'

###############################################################################
# Platform Check
###############################################################################

if [[ ! "$OSTYPE" =~ ^darwin ]]
then
  printf "notes-app-cli only works on macOS.\\nExiting...\\n"
  exit 0
fi

###############################################################################
# Environment
###############################################################################

# $_VERSION
#
# The most recent program version.
_VERSION="0.0.7"

# $_ME
#
# Set to the program's basename.
_ME="$(basename "${0}")"

# $_MY_PATH
#
# Set to the program's full path.
# shellcheck disable=SC2034
_MY_PATH="$(cd "$(dirname "$0")"; pwd)/$(basename "${0}")"

# $_MY_PROJECT_NAME
#
# Set to the program's project name.
# shellcheck disable=SC2034
_MY_PROJECT_NAME="notes-app-cli"

# $_MY_GITHUB_REPO
#
# Set to the program's primary GitHub repository URL.
# shellcheck disable=SC2034
_MY_GITHUB_REPO="xwmx/notes-app-cli"

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

# $_SED_I_COMMAND
#
# `sed -i` takes an extension on macOS, but that extension can cause errors in
# GNU `sed`.
#
# NOTE: To use this command, call it with `"${_SED_I_COMMAND[@]}"`
#
# https://stackoverflow.com/q/43171648
# http://stackoverflow.com/a/16746032
if sed --help >/dev/null 2>&1
then # GNU
  export _SED_I_COMMAND=(sed -i)
else # macOS
  export _SED_I_COMMAND=(sed -i '')
fi

# $_NEWLINE
#
# Use ANSI-C quoted newline for string building.
_NEWLINE=$'\n'

###############################################################################
# .notes-apprc
###############################################################################

# .notes-apprc
#
# If a `.notes-apprc` file exists in `$HOME`, source it.
export _MY_RC_PATH="${_MY_RC_PATH:-${HOME}/.notes-apprc}"
if [[ -e "${_MY_RC_PATH}" ]]
then
  _MY_RC_PATH="$(realpath "${_MY_RC_PATH}")"
  source "${_MY_RC_PATH}"
fi

###############################################################################
# $EDITOR
###############################################################################

# Set default $EDITOR if one has not been set.
if [[ -z "${EDITOR:-}" ]]
then
  if hash "code" 2>/dev/null
  then
    export EDITOR="code"
  elif hash "subl" 2>/dev/null
  then
    export EDITOR="subl"
  elif hash "mate" 2>/dev/null
  then
    export EDITOR="mate"
  elif hash "nano" 2>/dev/null
  then
    export EDITOR="nano"
  elif hash "vi" 2>/dev/null
  then
    export EDITOR="vi"
  else
    _die printf "\$EDITOR not found. Set the editor in ~/.notesrc\\n"
  fi
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\\n"
  fi
}

# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "${@}" 1>&2
  exit 1
}

# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# Temp Directory
###############################################################################

export _MY_TEMP_DIRECTORY
_MY_TEMP_DIRECTORY="$(mktemp -d)"

# Usage: _tempfile_path <basename>
_tempfile_path() {
  [[ -z "${1:-}" ]] && return 1
  printf "%s/%s" "${_MY_TEMP_DIRECTORY}" "${1:-}"
}

# Usage: _my_cleanup_on_exit
_my_cleanup_on_exit() {
  if [[ -n "${_MY_TEMP_DIRECTORY:-}" ]] &&
     [[ -e "${_MY_TEMP_DIRECTORY}"   ]]
  then
    rm -rf "${_MY_TEMP_DIRECTORY}"
  fi
}

trap _my_cleanup_on_exit EXIT

###############################################################################
# Configuration
###############################################################################

# `$_MY_DEFAULT_ACCOUNT_NAME`
export _MY_DEFAULT_ACCOUNT_NAME="${_MY_DEFAULT_ACCOUNT_NAME:-iCloud}"

# `$_MY_DEFAULT_FOLDER_NAME`
export _MY_DEFAULT_FOLDER_NAME="${_MY_DEFAULT_FOLDER_NAME:-Notes}"

# `$_MY_HIGHLIGHT_COLOR`
#
# Default: 11 (yellow) for 256 color terminals, 3 (yellow) for 8 color.
#
# Set highlighting color. This should be set to an xterm color number, usually
# a value between 1 and 256. For a table colors and their numbers run:
#
#   notes settings colors
#
# Supported Values: [0..255]
_set_my_highlight_color() {
  local _colors=
  _colors="$(tput colors)"
  if [[ -n "${_colors}" ]] && [[ "${_colors}" -gt 8 ]]
  then
    export _MY_HIGHLIGHT_COLOR="${_MY_HIGHLIGHT_COLOR:-11}"
  else
    export _MY_HIGHLIGHT_COLOR="${_MY_HIGHLIGHT_COLOR:-3}"
  fi
} && _set_my_highlight_color

###############################################################################
# Helpers
###############################################################################

# _alias_subcommand()
#
# Usage:
#   _alias_subcommand <subcommand> <alias>
#
# Description:
#   Create an <alias> of <subcommand>. NOTE: aliases also have to be added to
#   the $_SUBCOMMANDS variable.
_alias_subcommand() {
  local _subcommand="${1:-}"
  local _alias="${2:-}"
  if [[ -z "${_subcommand}" ]] || [[ -z "${_alias}" ]]
  then
    return 1
  fi

  local _subcommand_help
  _subcommand_help="$(
    printf "%s\\n" "${_subcommand}" | cut -d' ' -f1
  )"

  eval "desc \"${_alias}\" \"\$(_help '${_subcommand_help}')\""
  eval "_${_alias}() { _${_subcommand} \"\${@}\"; }"
}

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Takes a potential command <name> as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _test_list=(${*:2})
  for __test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \${__test_element}: %s\\n" "${__test_element}"
    if [[ "${__test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _edit_file()
#
# Usage:
#   _edit_file <path> [--no-wait]
#
# Description:
#   Open the file in $EDITOR. Use the `-f` option in vim and `--wait` option in
#   other GUI editors to wait until the file is closed in the editor before
#   continuing, unless `--no-wait`.
_edit_file() {
  local _file_path="${1:-}"
  local _wait=1

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --no-wait)
        _wait=0
        ;;
      *)
        if [[ -z "${_file_path}" ]]
        then
          _file_path="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_file_path}" ]]
  then
    return 1
  fi

  if ((_wait)) &&
     [[ "${EDITOR}" =~ mvim ]] ||
     [[ "${EDITOR}" =~ gvim ]]
  then
    "${EDITOR}" -f "${_file_path}"
  elif ((_wait)) &&
       [[ "${EDITOR}" =~ code ]] ||
       [[ "${EDITOR}" =~ mate ]] ||
       [[ "${EDITOR}" =~ subl ]]
  then
    "${EDITOR}" --wait "${_file_path}"
  else
    "${EDITOR}" "${_file_path}"
  fi
}

# _file_is_text()
#
# Usage:
#   _file_is_text <path>
#
# Returns:
#   0  If file is text.
#   1  if not.
_file_is_text() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # Avoid calling `file` for better performance.
  [[ "${_file_type}" =~ ^html|latex|md|markdown|org|rst|textile|txt$ ]] ||
    [[ "$(file -b --mime-type "${1:-}")" =~ ^text ]]
}

# _get_hash()
#
# Usage:
#   _get_hash <path>
#
# Description:
#   Generate a hash for the file at the given <path>.
_get_hash() {
  local _hash
  if _command_exists "md5sum"
  then
    _hash="$(md5sum "${1:-}" | awk '{ print $1 }')"
  elif _command_exists "md5"
  then
    _hash="$(md5 -q "${1:-}")"
  fi
  printf "%s\\n" "${_hash}"
}


# _get_id_normalized()
#
# Usage:
#   _get_id_normalized <id>
#
# Returns:
#   Return a formatted id suitable for including in AppleScript.
_get_id_normalized() {
  local _id="${1:-}"
  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "$(_get_id_type "${_id}")" == "id" ]]
  then
    _id="\"${_id}\""
  elif [[ "$(_get_id_type "${_id}")" == "number" ]]
  then # enclose name in quotes
    _id="\"${_id}\""
  fi

  printf "%s\\n" "${_id}"
}

# _get_id_selector()
#
# Usage:
#   _get_id_selector <id>
#
# Returns:
#   A formatted id suitable as a simple selector in AppleScript.
_get_id_selector() {
  local _id="${1:-}"
  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "$(_get_id_type "${_id}")" == "id" ]]
  then
    _id="id \"${_id}\""
  elif [[ ! "$(_get_id_type "${_id}")" == "number" ]]
  then # enclose name in quotes
    _id="\"${_id}\""
  fi

  printf "%s\\n" "${_id}"
}

# _get_id_type()
#
# Usage:
#   _get_id_type <id>
#
# Returns:
#   id      If id is a Notes.app id.
#   name    If the id is a name.
#   number  If the id is a number.
_get_id_type() {
  local _id="${1:-}"
  local _type=

  if [[ -z "${_id:-}" ]]
  then
    return 1
  elif [[ "${_id}" =~ x\-coredata\:\/\/ ]]
  then
    _type="id"
  elif [[ "${_id}" =~ ^[[:digit:]]+$ ]]
  then
    _type="number"
  else
    _type="name"
  fi

  printf "%s\\n" "${_type}"
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
export _TPUT_HIGHLIGHT_COLOR
_TPUT_HIGHLIGHT_COLOR="$(tput setaf "${_MY_HIGHLIGHT_COLOR}")"
export _TPUT_SGR0=    && _TPUT_SGR0="$(tput sgr0)"
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi

  printf "${_TPUT_HIGHLIGHT_COLOR:-}%s${_TPUT_SGR0:-}\\n" "${_input}"
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# _note_has_attachments()
#
# Usage:
#   _validate_no_attachments <note>
#
# Returns:
#   0  If the <note> has attachments.
#   1  If not.
_note_has_attachments() {
  local _note_name="${1:-}"

  if [[ -z "${_note_name:-}" ]]
  then
    return 1
  fi

  local _note_attachments
  _note_attachments="$(
    _attachments "${_note_name}" --properties id
  )"

  [[ -n "${_note_attachments[*]:-}" ]]
}


# __option_value_is_present()
#
# Usage:
#   __option_value_is_present "${variable}"
#
# Returns:
#   0  The argument is present and does not match an option flag.
#   1  The argument is blank or matches as an option flag.
__option_value_is_present() {
  [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  local _line=
  _text_length=${#_text}
  printf -v _line '%*s' "${_text_length}"
  printf "%s\\n" "${_line// /-}"
}

# _setup_folder()
#
# Usage:
#   _setup_folder <folder>
#
# Description:
#   Setup the folder to use for the subcommand.
_setup_folder() {
  local _folder_name="${1:-}"
  printf "%s\\n" "${_folder_name}"
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

# _validate_account_contains_folder()
#
# Usage:
#   _validate_account_contains_folder <account> <folder>
#
# Returns:
#   0  If the <account> contains <folder>.
#   1  If not.
_validate_account_contains_folder() {
  local _account_name="${1:-}"
  local _folder_name="${2:-}"

  if [[ -z "${_account_name:-}" ]] || [[ -z "${_folder_name:-}" ]]
  then
    return 1
  fi

  local _account_folders
  _account_folders="$(
    _folders \
      --account "${_account_name}" \
      --properties name
  )"

  _contains "${_folder_name}" "${_account_folders[@]}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _die printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _die printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# help
###############################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand> | -l | --long]

Options:
  -l --long  Include a list of subcommands and their descriptions.

Description:
  Print the program help information. When a subcommand name is passed, print
  the help information for the subcommand.

Shortcut Alias: \`h\`
HEREDOC
_help() {
  if [[ -z "${1:-}" ]] || [[ "${1}" =~ ^-l$|^--long$ ]]
  then
    cat <<HEREDOC
Notes.app CLI

A command line interface for Notes.app on macOS.

Usage:
  ${_ME} accounts [show <account>] [--properties <prop1>,<prop2>]
  ${_ME} add [<name>] [--account <account>] [--body <body>] [--folder <folder>]
  ${_ME} attachments <note> [--account <account>] [--folder <folder>]
                        [--properties <prop1>,<prop2>]
  ${_ME} commands
  ${_ME} count [--account <account>] [--folder <folder>]
  ${_ME} delete <note> [--account <account>] [--folder <folder>]
  ${_ME} edit <note> [--account <account>] [--folder <folder>]
  ${_ME} export <path> [--account <account>] [--folder <folder>]
                   [--note <note>]

  ${_ME} folders [show <folder>] [--account <account>] [--folder <folder>]
                    [--properties <prop1>,<prop2>]
  ${_ME} list [--account <account>] [--folder <folder>]
                 [--properties <prop1>,<prop2>]
  ${_ME} show <note> [--account <account>] [--folder <folder>] [--open]
                 [--properties <prop1>,<prop2>]
  ${_ME} update <note> (--body <body> | --name <name>) [--account <account>]
                   [--folder <folder>]
  ${_ME} -h | --help | help [<subcommand>] [-l | --long]
  ${_ME} --version | version

Help:
  ${_ME} help [<subcommand>]

More Information:
  https://github.com/${_MY_GITHUB_REPO}
HEREDOC

    if [[ "${1:-}" =~ ^-l$|^--long$ ]]
    then
      cat <<HEREDOC

Subcommands:
  (default)
  help         Display this help information.
  version      Display version information.

Program Options:
  -h --help         Display this help information.
  --version         Display version information.
HEREDOC
    fi
  else
    desc --get "${@}"
  fi
}
_alias_subcommand "help" "h"

###############################################################################
# Subcommands
###############################################################################

# accounts ####################################################################

desc "accounts" <<HEREDOC
Usage:
  ${_ME} accounts [show <account>] [--properties <prop1>,<prop2>]

Options:
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <account> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  name

Subcommands:
  (default)  List all accounts.
  show       Show properties of <account>.

Description:
  List accounts or show an account.

Examples:
  # List accounts by name.
  ${_ME} accounts

  # List accounts with ids and names.
  ${_ME} accounts --properties id,name

  # Print the id and name of the iCloud account.
  ${_ME} accounts show "iCloud"
HEREDOC
_accounts() {
  local _id=
  local _properties=
  local _subcommand="list"

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "accounts"
          return 1
        fi
        shift
        ;;
      show)
        if [[ "${_subcommand:-}" == "list" ]]
        then
          _subcommand="show"
        fi
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"
  _debug printf "\${_subcommand}: %s\\n" "${_subcommand:-}"

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  if [[ "${_subcommand}" == "list" ]]
  then
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  set myAccounts to accounts
  set myCounter to 0

  repeat with theAccount in myAccounts
    tell theAccount
      set myCounter to myCounter + 1
      -- log myCounter
HEREDOC

    read -r -d '' _script_footer <<HEREDOC || true
    end tell
  end repeat
end tell
HEREDOC

  if [[ "${_properties}" =~ id|^all$ ]]
  then
    _script_properties+=("set accountId to get id")
    _script_properties+=("log Id")
  fi

  if [[ "${_properties}" =~ name|^all$ ]]
  then
    _script_properties+=("set accountName to get name")
    _script_properties+=("log accountName")
  fi

  if [[ -z "${_script_properties[*]:-}" ]]
  then # no properties were specified
    _script_properties+=("set accountName to get name")
    _script_properties+=("log accountName")
  fi

  local _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  elif [[ "${_subcommand}" == "show" ]]
  then
    if [[ -z "${_id:-}" ]]
    then
      _help "show"
      return 1
    else
      _id="$(_get_id_selector "${_id}")"
    fi

    if [[ -z "${_properties:-}" ]]
    then # no properties were specified
      _properties="all"
    fi

    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_id}
HEREDOC

    read -r -d '' _script_footer <<HEREDOC || true
  end tell
end tell
HEREDOC

    if [[ "${_properties}" =~ id|^all$ ]]
    then
      _script_properties+=("set folderId to get id")
      _script_properties+=("log folderId")
    fi

    if [[ "${_properties}" =~ name|^all$ ]]
    then
      _script_properties+=("set folderName to get name")
      _script_properties+=("log folderName")
    fi
  fi

  _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# add #########################################################################

desc "add" <<HEREDOC
Usage:
  ${_ME} add [<name>] [--account <account>] [--body <body>] [--folder <folder>]

Options:
  --account <account>  The account containing the new note.
  --body    <body>     Plain text or HTML body content.
  --folder  <folder>   The folder containing the new note.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Add a new note. When no arguments are specified, a new blank note file is
  opened in the terminal editor, as set in the \`\$EDITOR\` environment
  variable.

  When <name> is specified, the editor is not opened and a new note is created
  containing the specified <name> as the first line of the note.

Note Format:
  The format of each note provided by Notes.app consists of:
    Line  1:     An unformatted string representing the "Name" property.
    Lines 2-end: An HTML formatted body.
  Within Notes.app the first line can be formatted, but this formatting is not
  preserved when the note is retrieved or set via AppleScript, so any
  formatting in this line will likely be lost or inconsistent with what's
  displayed in Notes.app.

Examples:
  # Open a new note in the editor.
  ${_ME} add

  # Create a new note named "Example name." without opening editor.
  ${_ME} add "Example name."

 # Create a new note with a name and body without opening editor.
  ${_ME} add "Example name." --body "Example body."
HEREDOC
_add() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _body=
  local _folder_name="${_MY_DEFAULT_FOLDER_NAME:-}"
  local _name=
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      --body)
        if __option_value_is_present "${_val:-}"
        then
          _body="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "add"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_name}" ]]
        then
          _name="${_arg}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_account_name:-}" ]]
  then
    _help "add"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -z "${_folder_name:-}" ]]
  then
    _help "add"
    return 1
  else
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_name}" ]]
  then
    local _temp_file
    _temp_file="$(mktemp)"

    if [[ -n "${_name}" ]]
    then
      printf "%s\\n" "${_name}" >> "${_temp_file}"
    fi

    _edit_file "${_temp_file}"

    _body=
    _name=

    while IFS= read -r __line
    do
      if [[ -z "${_name:-}" ]]
      then
        _name="${__line}"
      else
        _body+="${__line}${_NEWLINE}"
      fi
    done < "${_temp_file}"
  fi

  if [[ -z "${_body:-}" ]] && [[ -z "${_name:-}" ]]
  then
    return 1
  elif [[ -n "${_body:-}" ]] && [[ -n "${_name:-}" ]]
  then
    _properties="{name:\"${_name}\", body:\"${_body}\"}"
  elif [[ -n "${_body:-}" ]]
  then
    _properties="{body:\"${_body}\"}"
  elif [[ -n "${_name:-}" ]]
  then
    _properties="{name:\"${_name}\"}"
  fi

  read -r -d '' _script <<HEREDOC || true
tell application "Notes"
    tell account ${_account_name}
        make new note at folder ${_folder_name} with properties ${_properties}
    end tell
end tell
HEREDOC

  _debug printf "\${_script}: %s\\n" "${_script:-}"

  osascript -e "${_script}" 2>&1
}

# attachments #################################################################

desc "attachments" <<HEREDOC
Usage:
  ${_ME} attachments <note> [--account <account>] [--folder <folder>]
                        [--properties <prop1>,<prop2>]

Options:
  --account    <account>        The account containing the note.
  --folder     <folder>         The folder containing the note.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  name
  container
  contentIdentifier

Description:
  List attachments of <note> idenitied by <id>, <name>, or <number>.

Examples:
  # List attachments of note number 1.
  ${_ME} attachments 1

  # List attachment ids of note number 1.
  ${_ME} attachments 1 --properties id
HEREDOC
_attachments() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _id=
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "attachments"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "attachments"
          return 1
        fi
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "attachments"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_id:-}" ]]
  then
    _help "attachments"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  local _context_arguments=("${_id}")

  if [[ -z "${_account_name:-}" ]]
  then
    _help "attachments"
    return 1
  else
    _context_arguments+=("--account" "${_account_name}")
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _context_arguments+=("--folder" "${_folder_name}")
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  if [[ -z "${_properties:-}" ]]
  then # no properties were specified
    _properties="all"
  fi

  local _note_id=
  _note_id="$(_show "${_context_arguments[@]}" --properties id)"
  _note_id="$(_get_id_selector "${_note_id}")"

    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell note ${_id}
      set myAttachments to get attachments
      set myCounter to 0

      repeat with theAttachment in myAttachments
        tell theAttachment
          set myCounter to myCounter + 1
HEREDOC

    read -r -d '' _script_footer <<HEREDOC || true
        end tell
      end repeat
    end tell
  end tell
end tell
HEREDOC

  if [[ "${_properties}" =~ id|^all$ ]]
  then
    _script_properties+=("set attachmentId to get id")
    _script_properties+=("log attachmentId")
  fi

  if [[ "${_properties}" =~ name|^all$ ]]
  then
    _script_properties+=("set attachmentName to get name")
    _script_properties+=("log attachmentName")
  fi

  if [[ "${_properties}" =~ container|^all$ ]]
  then
    _script_properties+=("set attachmentContainer to get container")
    _script_properties+=("log attachmentContainer")
  fi

  if [[ "${_properties}" =~ containerIdentifier|^all$ ]]
  then
    _script_properties+=("set attachmentContentIdentifier to get content identifier")
    _script_properties+=("log attachmentContentIdentifier")
  fi

_script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# commands ####################################################################

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands

Description:
  List available commands.
HEREDOC
_commands() {
  printf "%s\\n" "${_SUBCOMMANDS[*]}"
}

# count #######################################################################

desc "count" <<HEREDOC
Usage:
  ${_ME} count [--account <account>] [--folder <folder>]

Description:
  Print the number of notes in <folder>.
HEREDOC
_count() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
    esac

    shift
  done

  if [[ -n "${_account_name:-}" ]] &&
     [[ -n "${_folder_name:-}"  ]] &&
     ! _validate_account_contains_folder "${_account_name}" "${_folder_name}"
  then
    printf "Account '%s' does not contain folder '%s'.\\n" \
      "${_account_name}" "${_folder_name}"
    return 1
  fi

  if [[ -z "${_account_name:-}" ]]
  then
    _help "count"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  local _script=

  if [[ -n "${_folder_name:-}" ]]
  then
    read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    set myFolder to folder ${_folder_name}
    get the count of notes of myFolder
  end tell
end tell
HEREDOC
  else
    read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  set myAccount to account ${_account_name}
  get the count of notes of myAccount
end tell
HEREDOC
  fi

  osascript -e "${_script}" 2>&1
}

# delete ######################################################################

desc "delete" <<HEREDOC
Usage:
  ${_ME} delete <note> [--account <account>] [--folder <folder>]

Options:
  --account <account>  The account containing the note.
  --folder  <folder>   The folder containing the note.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Delete <note>.
HEREDOC
_delete() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _force=0
  local _id=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "delete"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "delete"
          return 1
        fi
        ;;
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_account_name:-}" ]]
  then
    _help "delete"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_id:-}" ]]
  then
    _help "delete"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if ! ((_force))
  then
    if [[ -n "${_folder:-}" ]]
    then
      printf "Deleting '%s' in folder '%s' of account '%s'\\n" \
        "${_id}" \
        "${_folder_name}" \
        "${_account_name}"
    else
      printf "Deleting '%s' in account '%s'\\n" \
        "${_id}" \
        "${_account_name}"
    fi
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  if [[ -n "${_folder:-}" ]]
  then
    read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      delete note ${_id}
    end tell
  end tell
end tell
HEREDOC
  else
    read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    delete note ${_id}
  end tell
end tell
HEREDOC
  fi

  osascript -e "${_script}" 2>&1
}

# edit ########################################################################

desc "edit" <<HEREDOC
Usage:
  ${_ME} edit <note> [--account <account>] [--folder <folder>]

Options:
  --account    <account>  The account containing the note.
  --folder     <folder>   The folder containing the note.


Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Edit a note idenitied by <id>, <name>, or <number> in your terminal editor,
  as set in the \`\$EDITOR\` environment variable.

Note Format:
  The format of each note provided by Notes.app consists of:
    Line  1:     An unformatted string representing the "Name" property.
    Lines 2-end: An HTML formatted body.
  Within Notes.app the first line can be formatted, but this formatting is not
  preserved when the note is retrieved or set via AppleScript, so any
  formatting in this line will likely be lost or inconsistent with what's
  displayed in Notes.app.

Examples:
  # Open note number 1 in the editor.
  ${_ME} edit 1

  # Open note named "Todos" in the editor.
  ${_ME} edit Todos
HEREDOC
_edit() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _id=
  local _open_in_app=0
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "edit"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "edit"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_id:-}" ]]
  then
    _help "edit"
    return 1
  fi

  local _context_arguments=("${_id}")

  if [[ -n "${_account_name:-}" ]]
  then
    _context_arguments+=("--account" "${_account_name}")
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _context_arguments+=("--folder" "${_folder_name}")
  fi

  local _body=
  local _name=
  local _note_id=

  local _temp_file
  _temp_file="$(mktemp)"

  while read -r __line
  do
    if [[ -z "${_note_id:-}" ]]
    then
      _note_id="${__line}"
    elif [[ -z "${_name:-}" ]]
    then
      _name="${__line}"
    else
      _body+="${__line}${_NEWLINE}"
    fi
  done < <(_show "${_context_arguments[@]}" --properties id,name,body)

  if _note_has_attachments "${_note_id}"
  then
    printf "Note has attachments and can not be edited safely.\\n"
    return 1
  fi

  printf "%s\\n" "${_name}" >> "${_temp_file}"
  printf "%s\\n" "${_body}"  >> "${_temp_file}"

  _debug printf "%s\\n" "${_name}"
  _debug printf "%s\\n" "${_body}"

  _before="$(_get_hash "${_temp_file}")"
  _edit_file "${_temp_file}"
  _after="$(_get_hash "${_temp_file}")"

  if [[ "${_before}" != "${_after}" ]]
  then
    _body=
    _name=

    while IFS= read -r __line
    do
      if [[ -z "${_name:-}" ]]
      then
        _name="${__line}"
      else
        _body+="${__line}${_NEWLINE}"
      fi
    done < "${_temp_file}"

    _debug echo "---"
    _debug printf "%s\\n" "${_name}"
    _debug printf "%s\\n" "${_body}"

    _update "${_note_id}" --name "${_name}" --body "${_body}"
  fi
}

# env #########################################################################

desc "env" <<HEREDOC
Usage:
  ${_ME} env

Description:
  Print program environment variables.
HEREDOC
_env() {
  printf "EDITOR=%s\\n" "${EDITOR}"
  printf "_MY_TEMP_DIRECTORY=%s\\n" "${_MY_TEMP_DIRECTORY}"
  printf "_MY_HIGHLIGHT_COLOR=%s\\n" "${_MY_HIGHLIGHT_COLOR}"
  printf "_MY_RC_PATH=%s\\n" "${_MY_RC_PATH}"
}

# export ######################################################################

desc "export" <<HEREDOC
Usage:
  ${_ME} export <path> [--account <account>] [--folder <folder>]
                   [--note <note>]

Options:
  --account    <account>  The account containing the note.
  --folder     <folder>   The folder containing the note.
  --note       <note>     A note to export.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Export notes and save in directory at <path>. By default, all notes in the
  default account ($_MY_DEFAULT_ACCOUNT_NAME) are exported. Use --account,
  --folder, and --note flags to reduce the scope.

  Attachments are not included in exports. Apple does not provide easy access
  to attachments synced with iCloud.

Note Format:
  The format of each note provided by Notes.app consists of:
    Line  1:     An unformatted string representing the "Name" property.
    Lines 2-end: An HTML formatted body.
  Within Notes.app the first line can be formatted, but this formatting is not
  preserved when the note is retrieved or set via AppleScript, so any
  formatting in this line will likely be lost or inconsistent with what's
  displayed in Notes.app.

Examples:
  # Export all notes in the defualt account.
  ${_ME} export ~/Documents/Example

  # Export all notes in the folder named "Example Folder"
  ${_ME} export ~/Documents/Example --folder "Example Folder"
HEREDOC
_export() {
  local _account_name=
  local _include_attachments=0
  local _folder_name=
  local _id=
  local _macos_attachments_path="${HOME}/Library/Group Containers/group.com.apple.notes/Media"
  local _open_in_app=0
  local _note_name=
  local _properties=
  local _script=
  local _target_path=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "export"
          return 1
        fi
        ;;
      --attachments)
        _include_attachments=1
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "export"
          return 1
        fi
        ;;
      --note)
        if __option_value_is_present "${_val:-}"
        then
          _note_name="${_val}"
          shift
        else
          _help "export"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_target_path:-}" ]]
        then
          _target_path="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_target_path:-}" ]]
  then
    _help "export"
    return 1
  else
    if [[ "${_target_path}" == "." ]]
    then
      _target_path="$(pwd)"
    elif [[ "${_target_path}" == ".." ]]
    then
      _target_path="$(cd ..; pwd)"
    fi

    if [[ ! -e "${_target_path}" ]] || [[ ! -d "${_target_path}" ]]
    then
      printf "No directory found at '%s'\\n" "${_target_path}"
      return 1
    fi
  fi

  local _context_arguments=("${_id}")

  if [[ -n "${_account_name:-}" ]]
  then
    _context_arguments+=("--account" "${_account_name}")
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _context_arguments+=("--folder" "${_folder_name}")
  fi

  local _note_id_list=()

  if [[ -z "${_note_name:-}" ]]
  then
    printf \
      "Exporting %s items. This might take a while...\\n" \
      "$(_count "${_context_arguments[@]:-}")"
    _note_id_list=($(_list "${_context_arguments[@]:-}" --properties id))
  else
    printf \
      "Exporting 1 item. Please wait...\\n"
    _note_id_list=($(_show "${_note_name}" "${_context_arguments[@]:-}" --properties id))
  fi

  for __note_id in "${_note_id_list[@]}"
  do
    local _body=
    local _name=
    local _note_id=

    while read -r __line
    do
      if [[ -z "${_note_id:-}" ]]
      then
        _note_id="${__line}"
      elif [[ -z "${_name:-}" ]]
      then
        _name="${__line}"
      else
        _body+="${__line}${_NEWLINE}"
      fi
    done < <(_show "${__note_id}" "${_context_arguments[@]}" --properties id,name,body)

    local _note_id_truncated
    _note_id_truncated="$(basename "${_note_id:-}")"

    local _target_file_path="${_target_path}/${_note_id_truncated}.txt"

    local _temp_file
    _temp_file="$(mktemp)"

    printf "%s\\n" "${_name}" >> "${_temp_file}"
    printf "%s\\n" "${_body}" >> "${_temp_file}"

    if [[ -e "${_target_file_path}" ]] &&
       [[ "$(_get_hash "${_temp_file}")" == "$(_get_hash "${_target_file_path}")" ]]
    then
      printf "File exists and is unchanged: %s\\n" "${_target_path}"
      continue
    else
      cat "${_temp_file}" > "${_target_file_path}"
    fi

    if ((_include_attachments))
    then
      # NOTE: Saving the attachment via AppleScript silently fails. This
      # appears to be related to iCloud. More info:
      # https://forum.latenightsw.com/t/exporting-apple-notes-attachments/766/5
      # See git history (e.g., use `git blame` on this message) for an
      # AppleScript implementation.
      local _attachments_path="${_target_path}/${_note_id_truncated}"
      if [[ ! -e "${_attachments_path}" ]]
      then
        mkdir "${_attachments_path}"
      elif [[ ! -d "${_attachments_path}" ]]
      then
        printf "File exists at %s\\n" "${_attachments_path}"
        return 1
      fi

      local -a _attachment_ids_and_names=
      _attachment_ids_and_names=($(_attachments "${_note_id}" --properties id,name))

      local _counter=0

      while [[ "${_counter}" -lt "${#_attachment_ids_and_names[@]:-}" ]]
      do
        # local _attachment_id="${_attachment_ids_and_names[0]:-}"
        local _attachment_name="${_attachment_ids_and_names[1]:-}"

        local _attachment_target_path="${_attachments_path}/${_attachment_name}"

        local _attachment_path
        _attachment_path="$(
          find "${_macos_attachments_path}" -name "${_attachment_name}" \
            | head -n 1
        )"

        if [[ -f "${_attachment_path:-}" ]]
        then
          cp "${_attachment_path}" "${_attachment_target_path}" &&
            printf "Exported attachment to %s\\n" "${_attachment_target_path}"
        fi

        _counter=$((_counter+2))
      done
    fi

    printf "Exported to %s\\n" "${_target_file_path}"
  done


  _debug printf "%s\\n" "${_note_id_truncated}"
  _debug printf "%s\\n" "${_name}"
  _debug printf "%s\\n" "${_body}"
}

# folders #####################################################################

desc "folders" <<HEREDOC
Usage:
  ${_ME} folders [show <folder>] [--account <account>] [--folder <folder>]
                    [--properties <prop1>,<prop2>]

Options:
  --account    <account>        The account containing the folder.
  --folder     <folder>         The parent folder, if any.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  container
  name

Subcommands:
  (default)  List folders in the current account or folder.
  show       Show properties of <folder>.

Description:
  List folders in an account or show a folder.

Examples:
  # List all folders in the current account.
  ${_ME} folders

  # List all ids of folders in the "Example" account.
  ${_ME} folders --account Example --properties id

  # Show folder number 1.
  ${_ME} folders show 1
HEREDOC
_folders() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _id=
  local _properties=
  local _subcommand="list"

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "folders"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "folders"
          return 1
        fi
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "folders"
          return 1
        fi
        shift
        ;;
      show)
        if [[ "${_subcommand:-}" == "list" ]]
        then
          _subcommand="show"
        fi
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"
  _debug printf "\${_subcommand}: %s\\n" "${_subcommand:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "folders"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  _debug printf "\${_folder_name}: %s\\n" "${_folder_name:-}"

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  if [[ "${_subcommand}" == "list" ]]
  then

    if [[ -z "${_folder_name}" ]]
    then
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  set myAccount to account ${_account_name}
  tell myAccount
    set myFolders to folders of myAccount
    set myCounter to 0

    repeat with theFolder in myFolders
      tell theFolder
        set myCounter to myCounter + 1
        -- log myCounter
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end repeat
  end tell
end tell
HEREDOC
    else
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  set myAccount to account ${_account_name}
  tell myAccount
    set myFolder to folder ${_folder_name}
    tell myFolder
      set myFolders to folders of myFolder
      set myCounter to 0

      repeat with theFolder in myFolders
        tell theFolder
          set myCounter to myCounter + 1
          -- log myCounter
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
        end tell
      end repeat
    end tell
  end tell
end tell
HEREDOC
    fi

    if [[ "${_properties}" =~ container|^all$ ]]
    then
      _script_properties+=("set folderContainer to get container")
      _script_properties+=("log folderContainer")
    fi

    if [[ "${_properties}" =~ id|^all$ ]]
    then
      _script_properties+=("set folderId to get id")
      _script_properties+=("log folderId")
    fi

    if [[ "${_properties}" =~ name|^all$ ]]
    then
      _script_properties+=("set folderName to get name")
      _script_properties+=("log folderName")
    fi

    if [[ -z "${_script_properties[*]:-}" ]]
    then # no properties were specified
      _script_properties+=("set folderName to get name")
      _script_properties+=("log folderName")
    fi

    local _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  elif [[ "${_subcommand}" == "show" ]]
  then
    if [[ -z "${_id:-}" ]]
    then
      _help "show"
      return 1
    else
      _id="$(_get_id_selector "${_id}")"
    fi

    if [[ -z "${_properties:-}" ]]
    then # no properties were specified
      _properties="all"
    fi

    if [[ -n "${_folder_name}" ]]
    then
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      tell folder ${_id}
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end tell
  end tell
end tell
HEREDOC
    else
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_id}
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
    end tell
  end tell
end tell
HEREDOC
    fi

    if [[ "${_properties}" =~ container|^all$ ]]
    then
      _script_properties+=("set folderContainer to get container")
      _script_properties+=("log folderContainer")
    fi

    if [[ "${_properties}" =~ id|^all$ ]]
    then
      _script_properties+=("set folderId to get id")
      _script_properties+=("log folderId")
    fi

    if [[ "${_properties}" =~ name|^all$ ]]
    then
      _script_properties+=("set folderName to get name")
      _script_properties+=("log folderName")
    fi
  fi

  _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# list ########################################################################

desc "list" <<HEREDOC
Usage:
  ${_ME} list [--account <account>] [--folder <folder>]
                 [--properties <prop1>,<prop2>]

Options:
  --account <account>           The account containing the note.
  --folder  <folder>            The folder containing the note.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <account> and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  counter
  id
  container
  passwordProtected
  creationDate
  modificationDate
  name
  body

Description:
  List notes.

Examples:
  # List all notes in the default account.
  ${_ME} list

  # List all notes in the account named "Example"
  ${_ME} list --account Example

  # List all ids of notes in the folder named "Sample"
  ${_ME} list --folder Sample --properties id
HEREDOC
_list() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _properties=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "list"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "list"
          return 1
        fi
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "folders"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "list"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  local _script_footer=
  local _script_header=
  local -a _script_properties=()

  if [[ -n "${_folder_name:-}" ]]
  then
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    set myFolder to folder ${_folder_name}
    set myNotes to notes of myFolder
    set myCounter to 0

    repeat with theNote in myNotes
      tell theNote
        set myCounter to myCounter + 1
HEREDOC
  else
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  set myAccount to account ${_account_name}
  tell account ${_account_name}
    set myNotes to notes of myAccount
    set myCounter to 0

    repeat with theNote in myNotes
      tell theNote
        set myCounter to myCounter + 1
HEREDOC
  fi

  read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end repeat
  end tell
end tell
HEREDOC

  if [[ "${_properties}" =~ counter|^all$ ]]
  then
    _script_properties+=("log myCounter")
  fi

  if [[ "${_properties}" =~ id|^all$ ]]
  then
    _script_properties+=("set noteId to get id")
    _script_properties+=("log noteId")
  fi

  if [[ "${_properties}" =~ container|^all$ ]]
  then
    _script_properties+=("set noteContainer to get container")
    _script_properties+=("log noteContainer")
  fi

  if [[ "${_properties}" =~ passwordProtected|^all$ ]]
  then
    _script_properties+=("set notePasswordProtected to get password protected")
    _script_properties+=("log notePasswordProtected")
  fi

  if [[ "${_properties}" =~ creationDate|^all$ ]]
  then
    _script_properties+=("set noteCreationDate to get creation date")
    _script_properties+=("log noteCreationDate")
  fi

  if [[ "${_properties}" =~ modificationDate|^all$ ]]
  then
    _script_properties+=("set noteModificationDate to get modification date")
    _script_properties+=("log noteModificationDate")
  fi

  if [[ "${_properties}" =~ name|^all$ ]]
  then
    _script_properties+=("set noteName to get name")
    _script_properties+=("log noteName")
  fi

  if [[ "${_properties}" =~ body|^all$ ]]
  then
    _script_properties+=("set noteBody to get body")
    _script_properties+=("log noteBody")
  fi

  if [[ -z "${_script_properties[*]:-}" ]]
  then # no properties were specified
    _script_properties+=("set noteName to get name")
    _script_properties+=("log noteName")
  fi

local _script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# show ########################################################################

desc "show" <<HEREDOC
Usage:
  ${_ME} show <note> [--account <account>] [--folder <folder>] [--open]
                 [--properties <prop1>,<prop2>]

Options:
  --account    <account>        The account containing the note.
  --folder     <folder>         The folder containing the note.
  --open                        Open the note in Notes.app.
  --properties <prop1>,<prop2>  A comma-separated list of property names to
                                include in the output. Set to 'all' to include
                                all properties.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Available Properties:
  all
  id
  container
  passwordProtected
  creationDate
  modificationDate
  name
  body

Description:
  Show a note idenitied by <id>, <name>, or <number>.

Examples:
  # Print all properties for the note named "Shopping List"
  ${_ME} show "Shopping List"

  # Print the creationDate of note number 1.
  ${_ME} show 1 --properties creationDate
HEREDOC
_show() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _id=
  local _open_in_app=0
  local _properties=
  local _script=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "show"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "show"
          return 1
        fi
        ;;
      --open)
        _open_in_app=1
        ;;
      --properties)
        if [[ -n "${_val:-}" ]] && [[ ! "${_val:-}" =~ ^- ]]
        then
          _properties="$(printf "%s\\n" "${_val}" | tr ',' ' ')"
        else
          _help "show"
          return 1
        fi
        shift
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "\${_properties}: %s\\n" "${_properties[*]:-}"

  if [[ -z "${_account_name:-}" ]]
  then
    _help "show"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_id:-}" ]]
  then
    _help "show"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if ((_open_in_app))
  then
    if [[ -n "${_folder_name:-}" ]]
    then
      read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      show note ${_id}
    end tell
  end tell
end tell
HEREDOC
    else
      read -r -d '' _script <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    show note ${_id}
  end tell
end tell
HEREDOC
    fi
  else
    local _script_footer=
    local _script_header=
    local -a _script_properties=()

    if [[ -z "${_properties:-}" ]]
    then # no properties were specified
      _properties="all"
    fi

    if [[ -n "${_folder_name:-}" ]]
    then
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      tell note ${_id}
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end tell
  end tell
end tell
HEREDOC
    else
      read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell note ${_id}
HEREDOC

      read -r -d '' _script_footer <<HEREDOC || true
    end tell
  end tell
end tell
HEREDOC
    fi

    if [[ "${_properties}" =~ id|^all$ ]]
    then
      _script_properties+=("set noteId to get id")
      _script_properties+=("log noteId")
    fi

    if [[ "${_properties}" =~ container|^all$ ]]
    then
      _script_properties+=("set noteContainer to get container")
      _script_properties+=("log noteContainer")
    fi

    if [[ "${_properties}" =~ passwordProtected|^all$ ]]
    then
      _script_properties+=("set notePasswordProtected to get password protected")
      _script_properties+=("log notePasswordProtected")
    fi

    if [[ "${_properties}" =~ creationDate|^all$ ]]
    then
      _script_properties+=("set noteCreationDate to get creation date")
      _script_properties+=("log noteCreationDate")
    fi

    if [[ "${_properties}" =~ modificationDate|^all$ ]]
    then
      _script_properties+=("set noteModificationDate to get modification date")
      _script_properties+=("log noteModificationDate")
    fi

    if [[ "${_properties}" =~ name|^all$ ]]
    then
      _script_properties+=("set noteName to get name")
      _script_properties+=("log noteName")
    fi

    if [[ "${_properties}" =~ body|^all$ ]]
    then
      _script_properties+=("set noteBody to get body")
      _script_properties+=("log noteBody")
    fi


_script="\
${_script_header}
${_script_properties[*]:-}
${_script_footer}"
  fi

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1
}

# sync ########################################################################

desc "sync" <<HEREDOC
Usage:
  ${_ME} sync <folder> <path> [--account <account>] [--folder <folder>]
HEREDOC
_sync() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _folder_name=
  local _parent_folder_name=
  local _target_path=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _parent_folder_name="${_val}"
          shift
        else
          _help "count"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_folder_name:-}" ]]
        then
          _folder_name="${_arg:-}"
        elif [[ -z "${_target_path:-}" ]]
        then
          _target_path="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_target_path:-}" ]]
  then
    _help "sync"
    return 1
  else
    if [[ "${_target_path}" == "." ]]
    then
      _target_path="$(pwd)"
    elif [[ "${_target_path}" == ".." ]]
    then
      _target_path="$(cd ..; pwd)"
    fi

    if [[ ! -e "${_target_path}" ]] || [[ ! -d "${_target_path}" ]]
    then
      printf "No directory found at '%s'\\n" "${_target_path}"
      return 1
    fi
  fi

  if [[ -n "${_account_name:-}" ]] &&
     [[ -n "${_folder_name:-}"  ]] &&
     ! _validate_account_contains_folder "${_account_name}" "${_folder_name}"
  then
    printf "Account '%s' does not contain folder '%s'.\\n" \
      "${_account_name}" "${_folder_name}"
    return 1
  fi

  if [[ -z "${_account_name:-}" ]]
  then
    _help "sync"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_parent_folder_name:-}" ]]
  then
    _parent_folder_name="$(_get_id_selector "${_parent_folder_name}")"
  fi

  _export --folder "${_folder_name}" "${_target_path}"
  # .last-sync-index
  # .index

}

# update ######################################################################

desc "update" <<HEREDOC
Usage:
  ${_ME} update <note> (--body <body> | --name <name>) [--account <account>]
                   [--folder <folder>]

Options:
  --account <account>  The account containing the note.
  --body    <body>     The new value for the note body.
  --folder  <folder>   The folder containing the note.
  --name    <name>     The new value for the note name.

Identifiers:
  <note>, <account>, and <folder> can be identified with one of the following:
    id      The Notes.app core data id (starts with 'x-coredata://').
    name    The name property.
    number  The current sequence number.

Description:
  Update a note.

Examples:
  # Set the name of note number 1 to "Example Name".
  ${_ME} update 1 --name "Example Name"
HEREDOC
_update() {
  local _account_name="${_MY_DEFAULT_ACCOUNT_NAME:-}"
  local _body=
  local _folder_name=
  local _id=
  local _name=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --account)
        if __option_value_is_present "${_val:-}"
        then
          _account_name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --body)
        if [[ -n "${_val:-}" ]]
        then
          _body="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --folder)
        if __option_value_is_present "${_val:-}"
        then
          _folder_name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      --name)
        if [[ -n "${_val:-}" ]]
        then
          _name="${_val}"
          shift
        else
          _help "update"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_id:-}" ]]
        then
          _id="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_id:-}" ]]
  then
    _help "update"
    return 1
  else
    _id="$(_get_id_selector "${_id}")"
  fi

  if _note_has_attachments "${_id}"
  then
    printf "Note has attachments and can not be edited safely.\\n"
    return 1
  fi

  if [[ -z "${_account_name:-}" ]]
  then
    _help "update"
    return 1
  else
    _account_name="$(_get_id_selector "${_account_name}")"
  fi

  if [[ -n "${_folder_name:-}" ]]
  then
    _folder_name="$(_get_id_selector "${_folder_name}")"
  fi

  if [[ -z "${_body:-}" ]] && [[ -z "${_name:-}" ]]
  then
    return 1
  fi

  local _script_header=
  local _script_body=
  local _script_name=
  local _script_footer=

  if [[ -n "${_folder_name:-}" ]]
  then
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell folder ${_folder_name}
      tell note ${_id}
HEREDOC
    read -r -d '' _script_footer <<HEREDOC || true
      end tell
    end tell
  end tell
end tell
HEREDOC
  else
    read -r -d '' _script_header <<HEREDOC || true
tell application "Notes"
  tell account ${_account_name}
    tell note ${_id}
HEREDOC
    read -r -d '' _script_footer <<HEREDOC || true
    end tell
  end tell
end tell
HEREDOC
  fi


  if [[ -n "${_body:-}" ]]
  then
    _script_body="set the body of it to \"${_body}\""
  fi

  if [[ -n "${_name:-}" ]]
  then
    _script_name="set the name of it to \"${_name}\""
  fi


local _script="\
${_script_header}
${_script_body}
${_script_name}
${_script_footer}"

  _debug printf "\${_script}: %s\\n" "${_script}"

  osascript -e "${_script}" 2>&1 &&
    printf "Updated Note.\\n"
}

# version ####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\\n" "${_VERSION}"
}

###############################################################################
# _notes_app_main()
###############################################################################

# _notes_app_main()
#
# Description:
#   Call the appropriate subcommand.
_notes_app_main() {
  _debug printf "_notes_app_main() >> start\\n"
  _debug printf "_notes_app_main() \${@}: '%s'\\n" "${@}"
  _debug printf "_notes_app_main() \${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="help"
  fi

  case "${_SUBCOMMAND}" in
    commands|env|help|version)
      "_${_SUBCOMMAND}" "${@}"
      ;;
    *)
      "_${_SUBCOMMAND}" "${@}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_ARGUMENTS=()

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  accounts
  add
  attachments
  commands
  count
  delete
  edit
  env
  export
  folders
  h
  help
  list
  show
  sync
  update
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"



# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  case "${1:-}" in
    ${_SUBCOMMANDS_PATTERN})
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while ((${#}))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    *)
      if [[ -z "${_SUBCOMMAND:-}" ]] && _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\${_SUBCOMMANDS[*]}: '%s'\\n" "${_SUBCOMMANDS[*]}"
_debug printf "\${_SUBCOMMANDS_PATTERN}: '%s'\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"
_debug printf "\${_ARGUMENTS[*:-]}: '%s'\\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Describe:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("${_PRINT_HELP}"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("${_PRINT_VERSION}"))
  then
    _version
  else
    _notes_app_main "${_ARGUMENTS[@]:-}"
  fi
}

_main "${@:-}"
